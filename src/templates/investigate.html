{% extends "base.html" %}

{% block title %}Investigate{% endblock %}

{% block page_title %}Video Chat{% endblock %}

{% block extra_head %}
<style>
    .chat-layout {
        display: grid;
        grid-template-columns: 280px 1fr;
        gap: 1rem;
        min-height: calc(100vh - 240px);
    }
    .chat-sidebar {
        border: 1px solid var(--bs-border-color);
        border-radius: 12px;
        background: var(--bs-body-bg);
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    .chat-sidebar-header {
        padding: 0.75rem;
        border-bottom: 1px solid var(--bs-border-color);
        position: sticky;
        top: 0;
        z-index: 2;
        background: var(--bs-body-bg);
    }
    .chat-sidebar-header-controls {
        display: flex;
        gap: 0.5rem;
    }
    .chat-history-toggle {
        display: none;
        white-space: nowrap;
    }
    .chat-session-list {
        overflow-y: auto;
        overflow-x: hidden;
        scrollbar-gutter: stable;
        padding: 0.5rem;
        display: grid;
        gap: 0.4rem;
    }
    .chat-session-link {
        display: block;
        min-width: 0;
        overflow: hidden;
        text-decoration: none;
        color: inherit;
        border: 1px solid var(--bs-border-color);
        border-radius: 8px;
        padding: 0.55rem 0.65rem;
        background: var(--bs-secondary-bg);
        transition: border-color 0.15s ease, background-color 0.15s ease, box-shadow 0.15s ease;
    }
    .chat-session-link:hover {
        border-color: var(--bs-primary);
        background: rgba(13, 110, 253, 0.06);
    }
    .chat-session-link.active {
        border-color: var(--bs-primary);
        background: rgba(13, 110, 253, 0.12);
        box-shadow: inset 3px 0 0 var(--bs-primary);
    }
    .chat-session-title {
        display: -webkit-box;
        max-width: 100%;
        font-size: 0.93rem;
        font-weight: 600;
        line-height: 1.3;
        max-height: calc(1.3em * 2);
        white-space: normal;
        overflow: hidden;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        text-overflow: ellipsis;
        animation: none;
        transform: none;
    }
    .chat-session-meta {
        font-size: 0.78rem;
        color: var(--bs-secondary-color);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .chat-shell {
        border: 1px solid var(--bs-border-color);
        border-radius: 12px;
        background: var(--bs-body-bg);
        display: flex;
        flex-direction: column;
        min-height: 520px;
        height: calc(100vh - 240px);
    }
    .chat-messages {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 1rem;
        background: var(--bs-secondary-bg);
    }
    .chat-row {
        display: flex;
        margin-bottom: 0.75rem;
        min-width: 0;
    }
    .chat-row.user {
        justify-content: flex-end;
    }
    .chat-row.assistant {
        justify-content: flex-start;
    }
    .chat-row.system {
        justify-content: center;
    }
    .chat-bubble {
        max-width: min(760px, 88%);
        min-width: 0;
        padding: 0.75rem 0.9rem;
        border-radius: 14px;
        white-space: pre-wrap;
        line-height: 1.45;
        overflow-wrap: anywhere;
        word-break: break-word;
        border: 1px solid var(--bs-border-color);
    }
    .chat-bubble pre,
    .chat-bubble code {
        white-space: pre-wrap;
        overflow-wrap: anywhere;
        word-break: break-word;
    }
    .chat-bubble pre {
        max-width: 100%;
        overflow-x: auto;
    }
    .chat-bubble > :last-child {
        margin-bottom: 0;
    }
    .chat-bubble p {
        margin: 0 0 0.45rem;
    }
    .chat-bubble ul,
    .chat-bubble ol {
        margin: 0.3rem 0 0.45rem;
        padding-left: 1.15rem;
    }
    .chat-bubble li {
        margin: 0.12rem 0;
    }
    .chat-bubble li > p {
        margin: 0.1rem 0;
    }
    .chat-row.user .chat-bubble {
        background: var(--bs-primary);
        color: #fff;
        border-color: var(--bs-primary);
    }
    .chat-row.assistant .chat-bubble {
        background: var(--bs-body-bg);
    }
    .chat-row.system .chat-bubble {
        max-width: min(820px, 95%);
        background: var(--bs-tertiary-bg);
        color: var(--bs-secondary-color);
        font-size: 0.9rem;
    }
    .tool-progress .tool-current {
        color: var(--bs-body-color);
        font-size: 0.95rem;
        overflow-wrap: anywhere;
        word-break: break-word;
    }
    .tool-progress-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.4rem;
    }
    .tool-progress details summary {
        cursor: pointer;
        color: var(--bs-secondary-color);
        overflow-wrap: anywhere;
        word-break: break-word;
    }
    .tool-progress .tool-history-items {
        max-height: 180px;
        overflow-y: auto;
        border-left: 2px solid var(--bs-border-color);
        padding-left: 0.6rem;
    }
    .tool-progress .tool-history-item {
        margin-bottom: 0.35rem;
        color: var(--bs-secondary-color);
        overflow-wrap: anywhere;
        word-break: break-word;
    }
    .evidence-wrap {
        margin-top: 0.75rem;
        display: grid;
        gap: 0.5rem;
    }
    .evidence-card {
        border: 1px solid var(--bs-border-color);
        border-radius: 10px;
        background: var(--bs-body-bg);
        padding: 0.65rem 0.75rem;
        position: relative;
    }
    .evidence-title {
        font-weight: 600;
        margin-bottom: 0.25rem;
    }
    .evidence-meta {
        font-size: 0.82rem;
        color: var(--bs-secondary-color);
        margin-bottom: 0.35rem;
    }
    .evidence-body {
        display: grid;
        grid-template-columns: 160px 1fr;
        gap: 0.65rem;
        align-items: start;
    }
    .evidence-text {
        min-width: 0;
    }
    .evidence-snippet {
        font-size: 0.9rem;
        color: var(--bs-secondary-color);
        margin-bottom: 0.35rem;
    }
    .evidence-link {
        width: 100%;
        margin-top: 0.15rem;
        font-weight: 600;
    }
    .evidence-actions {
        display: grid;
        gap: 0.35rem;
        margin-top: 0.2rem;
    }
    .evidence-inline-player {
        display: none;
        margin-top: 0.5rem;
        border: 1px solid var(--bs-border-color);
        border-radius: 8px;
        overflow: hidden;
        background: #000;
    }
    .evidence-inline-player.open {
        display: block;
    }
    .evidence-inline-player video {
        width: 100%;
        max-height: 260px;
        display: block;
        background: #000;
    }
    .evidence-preview {
        position: relative;
        width: 160px;
        height: 90px;
        background: #000;
        overflow: hidden;
        border: 1px solid var(--bs-border-color);
        border-radius: 6px;
        margin-bottom: 0.5rem;
    }
    .evidence-preview img {
        position: absolute;
        max-width: none;
    }
    @media (max-width: 576px) {
        .evidence-body {
            grid-template-columns: 1fr;
        }
    }
    .chat-footer {
        border-top: 1px solid var(--bs-border-color);
        padding: 0.75rem;
        background: var(--bs-body-bg);
    }
    .chat-status {
        min-height: 1.1rem;
    }
    @media (max-width: 960px) {
        .chat-layout {
            grid-template-columns: 1fr;
        }
        .chat-sidebar {
            min-height: 0;
            max-height: none;
        }
        .chat-sidebar-header {
            border-bottom: none;
        }
        .chat-history-toggle {
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .chat-session-list {
            display: none;
            max-height: 230px;
            border-top: 1px solid var(--bs-border-color);
        }
        .chat-sidebar.expanded .chat-sidebar-header {
            border-bottom: 1px solid var(--bs-border-color);
        }
        .chat-sidebar.expanded .chat-session-list {
            display: grid;
        }
        .chat-shell {
            min-height: 0;
            height: auto;
        }
        .chat-messages {
            min-height: 50vh;
        }
        .chat-session-title {
            overflow: hidden;
            text-overflow: ellipsis;
        }
    }
    @media (max-width: 576px) {
        .chat-messages {
            padding: 0.75rem;
            min-height: 56vh;
            padding-bottom: 6.5rem;
        }
        .chat-bubble {
            max-width: 100%;
            padding: 0.7rem 0.8rem;
        }
        .chat-footer {
            padding: 0.65rem;
            position: sticky;
            bottom: 0;
            z-index: 5;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.18);
        }
        .chat-footer .input-group {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.5rem;
        }
        .chat-footer .input-group > .form-control,
        .chat-footer .input-group > .btn {
            width: 100%;
            border-radius: 0.375rem !important;
        }
        .tool-progress-header {
            flex-direction: column;
            align-items: flex-start;
        }
        .tool-progress .badge {
            font-size: 0.72rem;
        }
        .evidence-snippet {
            font-size: 0.88rem;
        }
        .footer .text-muted {
            display: none;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="chat-layout">
    <aside class="chat-sidebar">
        <div class="chat-sidebar-header">
            <div class="chat-sidebar-header-controls">
                <button id="new-chat-button" class="btn btn-primary flex-grow-1" type="button">New chat</button>
                <button id="chat-history-toggle" class="btn btn-outline-secondary chat-history-toggle" type="button" aria-expanded="false">Chats</button>
            </div>
        </div>
        <div id="chat-session-list" class="chat-session-list"></div>
    </aside>

    <div class="chat-shell">
        <div id="chat-messages" class="chat-messages"></div>
        <div class="chat-footer">
            <form id="chat-form">
                <div class="input-group">
                    <input id="chat-input" type="text" class="form-control" placeholder="Ask about your videos..." required>
                    <button id="send-button" class="btn btn-primary" type="submit">Send</button>
                </div>
            </form>
            <div id="chat-status" class="chat-status small text-muted mt-2"></div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.7/dist/purify.min.js"></script>
<script>
(() => {
    const currentChatId = "{{ chat_id | default(value='') }}";
    const chatMessages = document.getElementById("chat-messages");
    const chatSessionList = document.getElementById("chat-session-list");
    const chatForm = document.getElementById("chat-form");
    const chatInput = document.getElementById("chat-input");
    const sendButton = document.getElementById("send-button");
    const chatStatus = document.getElementById("chat-status");
    const newChatButton = document.getElementById("new-chat-button");
    const chatHistoryToggle = document.getElementById("chat-history-toggle");
    const chatSidebar = document.querySelector(".chat-sidebar");

    let activeRunId = null;
    let currentPreviewInterval = null;
    const previewVttData = {};

    function scrollToBottom() {
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function escapeHtml(text) {
        return text
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll("\"", "&quot;")
            .replaceAll("'", "&#39;");
    }

    function renderMarkdown(markdownText) {
        if (window.marked && typeof window.marked.parse === "function") {
            const html = window.marked.parse(markdownText || "", {
                breaks: true,
                gfm: true
            });
            if (window.DOMPurify && typeof window.DOMPurify.sanitize === "function") {
                return window.DOMPurify.sanitize(html);
            }
            return html;
        }
        return escapeHtml(markdownText || "").replaceAll("\n", "<br>");
    }

    function appendMessage(role, text = "") {
        const row = document.createElement("div");
        row.className = `chat-row ${role}`;

        const bubble = document.createElement("div");
        bubble.className = "chat-bubble";
        bubble.textContent = text;

        row.appendChild(bubble);
        chatMessages.appendChild(row);
        scrollToBottom();
        return bubble;
    }

    function setBubbleMarkdown(bubble, markdownText) {
        bubble.innerHTML = renderMarkdown(markdownText);
        scrollToBottom();
    }

    function appendEvidenceToBubble(bubble, evidenceItems) {
        if (!Array.isArray(evidenceItems) || evidenceItems.length === 0) return;

        const heading = document.createElement("div");
        heading.className = "mt-3 mb-2 fw-semibold";
        heading.textContent = "Relevant video moments";
        bubble.appendChild(heading);

        const wrap = document.createElement("div");
        wrap.className = "evidence-wrap";

        for (const item of evidenceItems) {
            const card = document.createElement("div");
            card.className = "evidence-card";
            const eventDurationSeconds = getEventDurationSeconds(item);

            const dateLabel = formatDateYYYYMMDD(item.event_start_local || item.event_end_local);
            const cameraLabel = prettifyCameraLabel(item.camera_name || item.camera_id);
            const title = document.createElement("div");
            title.className = "evidence-title";
            title.textContent = `${dateLabel || "Clip"} ${cameraLabel}`.trim();
            card.appendChild(title);

            if (item.event_start_local || item.event_end_local) {
                const meta = document.createElement("div");
                meta.className = "evidence-meta";
                const startTime = formatTimeShort(item.event_start_local);
                const endTime = formatTimeShort(item.event_end_local);
                meta.textContent = startTime && endTime ? `${startTime} to ${endTime}` : (startTime || endTime || "");
                card.appendChild(meta);
            }

            const body = document.createElement("div");
            body.className = "evidence-body";
            card.appendChild(body);

            const preview = document.createElement("div");
            preview.className = "evidence-preview";
            preview.dataset.eventId = item.event_id;
            preview.dataset.previewTime = Number.isFinite(Number(item.start_offset_sec))
                ? String(Math.max(0, Number(item.start_offset_sec)))
                : "0";
            preview.innerHTML = `<img src="" alt="Video preview">`;
            body.appendChild(preview);
            const previewImg = preview.querySelector("img");
            if (previewImg) {
                previewImg.src = `/api/storyboard/image/${encodeURIComponent(item.event_id)}`;
            }
            setPreviewFrameForOffset(item.event_id, preview, Number(preview.dataset.previewTime || "0"));

            const textCol = document.createElement("div");
            textCol.className = "evidence-text";
            body.appendChild(textCol);

            if (item.snippet) {
                const snippet = document.createElement("div");
                snippet.className = "evidence-snippet";
                snippet.textContent = item.snippet;
                textCol.appendChild(snippet);
            }

            const actions = document.createElement("div");
            actions.className = "evidence-actions";

            const playButton = document.createElement("button");
            playButton.type = "button";
            playButton.className = "btn btn-sm btn-primary";
            playButton.textContent = "Play here";
            actions.appendChild(playButton);

            const link = document.createElement("a");
            link.href = `/events/latest?video=${encodeURIComponent(item.event_id)}`;
            link.target = "_blank";
            link.rel = "noopener noreferrer";
            link.className = "evidence-link btn btn-sm btn-outline-primary";
            link.textContent = "View video elsewhere";
            actions.appendChild(link);
            textCol.appendChild(actions);

            const inlinePlayer = document.createElement("div");
            inlinePlayer.className = "evidence-inline-player";
            const video = document.createElement("video");
            video.controls = true;
            video.preload = "metadata";
            inlinePlayer.appendChild(video);
            textCol.appendChild(inlinePlayer);

            playButton.addEventListener("click", () => {
                const isOpen = inlinePlayer.classList.contains("open");
                if (isOpen) {
                    video.pause();
                    inlinePlayer.classList.remove("open");
                    playButton.textContent = "Play here";
                    return;
                }

                const startAt = Number.isFinite(Number(item.start_offset_sec))
                    ? Math.max(0, Number(item.start_offset_sec))
                    : 0;
                inlinePlayer.classList.add("open");
                playButton.textContent = "Hide player";

                if (!video.src) {
                    video.src = `/video/${encodeURIComponent(item.event_id)}`;
                }
                const seekAndPlay = () => {
                    video.currentTime = startAt;
                    video.play().catch(() => {});
                };
                if (video.readyState >= 1) {
                    seekAndPlay();
                } else {
                    video.addEventListener("loadedmetadata", seekAndPlay, { once: true });
                }
            });

            preview.addEventListener("mouseenter", () => {
                startPreview(item.event_id, card, eventDurationSeconds);
            });
            preview.addEventListener("mouseleave", () => {
                stopPreview(card);
            });

            wrap.appendChild(card);
        }

        bubble.appendChild(wrap);
        scrollToBottom();
    }

    function updateStatus(text) {
        chatStatus.textContent = text || "";
    }

    function createProgressTracker() {
        const row = document.createElement("div");
        row.className = "chat-row system";

        const bubble = document.createElement("div");
        bubble.className = "chat-bubble tool-progress";

        const header = document.createElement("div");
        header.className = "tool-progress-header";

        const title = document.createElement("span");
        title.className = "fw-semibold";
        title.textContent = "Investigation progress";
        header.appendChild(title);

        const stateBadge = document.createElement("span");
        stateBadge.className = "badge text-bg-secondary";
        stateBadge.textContent = "Running";
        header.appendChild(stateBadge);

        const current = document.createElement("div");
        current.className = "tool-current";
        current.textContent = "Starting...";

        const historyDetails = document.createElement("details");
        historyDetails.className = "mt-2";

        const summary = document.createElement("summary");
        summary.textContent = "Show full tool history (0)";
        historyDetails.appendChild(summary);

        const historyItems = document.createElement("div");
        historyItems.className = "tool-history-items small mt-2";
        historyDetails.appendChild(historyItems);

        bubble.appendChild(header);
        bubble.appendChild(current);
        bubble.appendChild(historyDetails);
        row.appendChild(bubble);
        chatMessages.appendChild(row);
        scrollToBottom();

        let count = 0;
        function addHistory(text) {
            const item = document.createElement("div");
            item.className = "tool-history-item";
            item.textContent = text;
            historyItems.appendChild(item);
            count += 1;
            summary.textContent = `Show full tool history (${count})`;
            scrollToBottom();
        }

        return {
            update(text) {
                current.textContent = text;
                addHistory(text);
            },
            complete(text) {
                if (text) {
                    current.textContent = text;
                }
                stateBadge.className = "badge text-bg-success";
                stateBadge.textContent = "Complete";
                if (count > 0) {
                    historyDetails.open = false;
                }
            },
            fail(text) {
                if (text) {
                    current.textContent = text;
                    addHistory(text);
                }
                stateBadge.className = "badge text-bg-danger";
                stateBadge.textContent = "Failed";
                historyDetails.open = true;
            }
        };
    }

    function formatSearchPlan(plan) {
        const queries = Array.isArray(plan.search_queries) ? plan.search_queries : [];
        const parts = [];
        if (queries.length === 0) {
            parts.push("queries=(none)");
        } else {
            parts.push(`queries=${queries.join(", ")}`);
        }
        if (plan.time_window_start_utc && plan.time_window_end_utc) {
            parts.push(`window=${plan.time_window_start_utc} to ${plan.time_window_end_utc}`);
        }
        return `transcript_search plan: ${parts.join(" | ")}`;
    }

    function formatRelative(unixSeconds) {
        if (!unixSeconds) return "";
        const d = new Date(unixSeconds * 1000);
        return d.toLocaleString();
    }

    function formatDateYYYYMMDD(value) {
        if (!value) return "";
        const parsed = new Date(value);
        if (Number.isNaN(parsed.getTime())) {
            const raw = String(value);
            return raw.includes("T") ? raw.split("T")[0] : raw;
        }
        const year = parsed.getFullYear();
        const month = String(parsed.getMonth() + 1).padStart(2, "0");
        const day = String(parsed.getDate()).padStart(2, "0");
        return `${year}-${month}-${day}`;
    }

    function formatTimeShort(value) {
        if (!value) return "";
        const parsed = new Date(value);
        if (Number.isNaN(parsed.getTime())) return "";
        return parsed.toLocaleTimeString([], { hour: "numeric", minute: "2-digit" });
    }

    function prettifyCameraLabel(cameraId) {
        if (!cameraId) return "Camera";
        return String(cameraId)
            .replaceAll("_", " ")
            .replaceAll("-", " ")
            .replace(/\s+/g, " ")
            .trim()
            .replace(/\b\w/g, (c) => c.toUpperCase());
    }

    function parseVttTimestamp(timeText) {
        const parts = String(timeText).trim().split(":");
        if (parts.length !== 3) return 0;
        const hours = Number(parts[0]) || 0;
        const minutes = Number(parts[1]) || 0;
        const seconds = Number(parts[2]) || 0;
        return (hours * 3600) + (minutes * 60) + seconds;
    }

    function parseVTT(vttText) {
        const frames = [];
        const lines = String(vttText || "").split("\n");
        let currentFrame = null;

        for (const line of lines) {
            if (line.includes("-->")) {
                const [startText, endText] = line.split("-->");
                currentFrame = {
                    startTime: parseVttTimestamp(startText),
                    endTime: parseVttTimestamp(endText)
                };
            } else if (line.includes("#xywh=") && currentFrame) {
                const xywh = line.split("#xywh=")[1].split(",").map(Number);
                currentFrame.position = xywh;
                frames.push(currentFrame);
                currentFrame = null;
            }
        }

        return frames;
    }

    function getEventDurationSeconds(item) {
        const start = new Date(item.event_start_utc || item.event_start_local || "");
        const end = new Date(item.event_end_utc || item.event_end_local || "");
        if (!Number.isNaN(start.getTime()) && !Number.isNaN(end.getTime())) {
            return Math.max(1, Math.ceil((end.getTime() - start.getTime()) / 1000));
        }
        const endOffset = Number(item.end_offset_sec);
        if (Number.isFinite(endOffset) && endOffset > 0) return Math.ceil(endOffset);
        return 15;
    }

    async function startPreview(eventId, element, durationSeconds) {
        const preview = element.querySelector(".evidence-preview");
        const previewImg = preview ? preview.querySelector("img") : null;
        if (!preview || !previewImg || !eventId) return;

        previewImg.src = `/api/storyboard/image/${encodeURIComponent(eventId)}`;

        if (currentPreviewInterval) {
            clearInterval(currentPreviewInterval);
        }

        if (!previewVttData[eventId]) {
            try {
                const response = await fetch(`/api/storyboard/vtt/${encodeURIComponent(eventId)}`);
                if (!response.ok) return;
                const vttText = await response.text();
                previewVttData[eventId] = parseVTT(vttText);
            } catch (_error) {
                return;
            }
        }

        const frames = await loadPreviewFrames(eventId);
        if (frames.length === 0) return;
        const startTime = Number(preview.dataset.previewTime || "0");
        const initialFrame = findFrameForTime(frames, startTime);
        if (initialFrame && Array.isArray(initialFrame.position)) {
            const [x, y] = initialFrame.position;
            previewImg.style.left = `-${x}px`;
            previewImg.style.top = `-${y}px`;
        }

        let currentTime = Number.isFinite(startTime) ? startTime : 0;
        const fps = 4;
        currentPreviewInterval = setInterval(() => {
            currentTime = (currentTime + 1) % Math.max(1, Math.ceil(durationSeconds));
            const frame = findFrameForTime(frames, currentTime);
            if (!frame || !Array.isArray(frame.position)) return;

            const [x, y] = frame.position;
            previewImg.style.left = `-${x}px`;
            previewImg.style.top = `-${y}px`;
        }, 1000 / fps);
    }

    function stopPreview(element) {
        const preview = element.querySelector(".evidence-preview");
        if (currentPreviewInterval) {
            clearInterval(currentPreviewInterval);
            currentPreviewInterval = null;
        }
        if (!preview) return;
        const eventId = preview.dataset.eventId || "";
        if (!eventId) return;
        const previewTime = Number(preview.dataset.previewTime || "0");
        setPreviewFrameForOffset(eventId, preview, previewTime);
    }

    async function loadPreviewFrames(eventId) {
        if (previewVttData[eventId]) {
            return previewVttData[eventId];
        }
        try {
            const response = await fetch(`/api/storyboard/vtt/${encodeURIComponent(eventId)}`);
            if (!response.ok) return [];
            const vttText = await response.text();
            previewVttData[eventId] = parseVTT(vttText);
            return previewVttData[eventId];
        } catch (_error) {
            return [];
        }
    }

    function findFrameForTime(frames, time) {
        if (!Array.isArray(frames) || frames.length === 0) return null;
        const clampedTime = Number.isFinite(time) ? Math.max(0, time) : 0;
        return frames.find((frame) => clampedTime >= frame.startTime && clampedTime <= frame.endTime)
            || frames[frames.length - 1];
    }

    async function setPreviewFrameForOffset(eventId, preview, timeSeconds) {
        if (!preview) return;
        const previewImg = preview.querySelector("img");
        if (!previewImg) return;
        const frames = await loadPreviewFrames(eventId);
        if (frames.length === 0) return;
        const frame = findFrameForTime(frames, timeSeconds);
        if (!frame || !Array.isArray(frame.position)) return;
        const [x, y] = frame.position;
        previewImg.style.left = `-${x}px`;
        previewImg.style.top = `-${y}px`;
    }

    function decodeJsonStringPrefix(source, startIndex) {
        let decoded = "";
        let i = startIndex;
        while (i < source.length) {
            const ch = source[i];
            if (ch === "\"") {
                return decoded;
            }
            if (ch !== "\\") {
                decoded += ch;
                i += 1;
                continue;
            }

            i += 1;
            if (i >= source.length) break;
            const escaped = source[i];
            if (escaped === "n") decoded += "\n";
            else if (escaped === "r") decoded += "\r";
            else if (escaped === "t") decoded += "\t";
            else if (escaped === "b") decoded += "\b";
            else if (escaped === "f") decoded += "\f";
            else if (escaped === "\"" || escaped === "\\" || escaped === "/") decoded += escaped;
            else if (escaped === "u") {
                const hex = source.slice(i + 1, i + 5);
                if (/^[0-9a-fA-F]{4}$/.test(hex)) {
                    decoded += String.fromCharCode(parseInt(hex, 16));
                    i += 4;
                } else {
                    break;
                }
            } else {
                decoded += escaped;
            }
            i += 1;
        }
        return decoded;
    }

    function extractAnswerTextFromPartialJson(rawText) {
        const keyIndex = rawText.indexOf("\"answer\"");
        if (keyIndex === -1) return null;

        let cursor = keyIndex + "\"answer\"".length;
        while (cursor < rawText.length && /\s/.test(rawText[cursor])) cursor += 1;
        if (rawText[cursor] !== ":") return null;
        cursor += 1;
        while (cursor < rawText.length && /\s/.test(rawText[cursor])) cursor += 1;
        if (rawText[cursor] !== "\"") return null;
        cursor += 1;

        return decodeJsonStringPrefix(rawText, cursor);
    }

    async function loadSidebar() {
        const response = await fetch("/api/chats");
        if (!response.ok) return;
        const sessions = await response.json();
        chatSessionList.innerHTML = "";

        for (const session of sessions) {
            const link = document.createElement("a");
            link.className = "chat-session-link";
            if (session.id === currentChatId) {
                link.classList.add("active");
            }
            link.href = `/investigate/${session.id}`;

            const title = document.createElement("div");
            title.className = "chat-session-title";
            const sessionTitle = session.title || "New chat";
            title.textContent = sessionTitle;
            title.title = sessionTitle;

            const meta = document.createElement("div");
            meta.className = "chat-session-meta";
            const updated = formatRelative(session.updated_at);
            const running = session.active_run_status ? ` â€¢ ${session.active_run_status}` : "";
            meta.textContent = `${updated}${running}`;

            link.appendChild(title);
            link.appendChild(meta);
            chatSessionList.appendChild(link);
        }
    }

    async function loadThread() {
        const response = await fetch(`/api/chats/${encodeURIComponent(currentChatId)}`);
        if (!response.ok) {
            updateStatus("Failed to load chat");
            return;
        }

        const thread = await response.json();
        chatMessages.innerHTML = "";

        if (!Array.isArray(thread.messages) || thread.messages.length === 0) {
            appendMessage("assistant", "Ask about events and I will answer with matching video moments you can open directly.");
        } else {
            for (const message of thread.messages) {
                const role = message.role === "user" ? "user" : "assistant";
                const bubble = appendMessage(role, "");
                setBubbleMarkdown(bubble, message.content || "");
                if (role === "assistant") {
                    appendEvidenceToBubble(bubble, message.evidence || []);
                }
            }
        }

        if (thread.active_run && thread.active_run.id) {
            activeRunId = thread.active_run.id;
            startRunStream(activeRunId);
        }
        scrollToBottom();
    }

    async function startRunStream(runId, assistantBubble) {
        updateStatus("Working...");
        const progressTracker = createProgressTracker();
        const bubble = assistantBubble || appendMessage("assistant", "");
        let assistantText = "";
        let assistantRawJson = "";

        const response = await fetch(`/api/chats/${encodeURIComponent(currentChatId)}/runs/${encodeURIComponent(runId)}/stream`);
        if (!response.ok || !response.body) {
            updateStatus("Failed to stream response");
            progressTracker.fail("Failed to connect stream");
            return;
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });

            let splitIndex;
            while ((splitIndex = buffer.indexOf("\n\n")) !== -1) {
                const block = buffer.slice(0, splitIndex);
                buffer = buffer.slice(splitIndex + 2);
                if (!block.trim()) continue;

                let eventType = "message";
                const dataLines = [];
                for (const line of block.split("\n")) {
                    if (line.startsWith("event:")) {
                        eventType = line.slice(6).trim();
                    } else if (line.startsWith("data:")) {
                        dataLines.push(line.slice(5));
                    }
                }
                const data = dataLines.join("\n");

                if (eventType === "status") {
                    updateStatus(data || "Working...");
                    if (data) {
                        progressTracker.update(`status: ${data}`);
                    }
                } else if (eventType === "search_plan") {
                    try {
                        const plan = JSON.parse(data);
                        progressTracker.update(formatSearchPlan(plan));
                    } catch (_e) {
                        // Ignore malformed payloads.
                    }
                } else if (eventType === "tool_use") {
                    try {
                        const event = JSON.parse(data);
                        const name = event && event.tool_name ? event.tool_name : "tool";
                        const stage = event && event.stage ? event.stage : "update";
                        const message = event && event.message ? event.message : "";
                        progressTracker.update(`[${name}] ${stage}: ${message}`);
                    } catch (_e) {
                        // Ignore malformed payloads.
                    }
                } else if (eventType === "answer_delta") {
                    try {
                        const payload = JSON.parse(data);
                        assistantRawJson += payload.delta || "";
                    } catch (_e) {
                        assistantRawJson += data;
                    }
                    const extractedText = extractAnswerTextFromPartialJson(assistantRawJson);
                    assistantText = extractedText !== null ? extractedText : assistantRawJson;
                    setBubbleMarkdown(bubble, assistantText);
                } else if (eventType === "done") {
                    let donePayload = null;
                    try {
                        donePayload = JSON.parse(data);
                    } catch (_e) {
                        donePayload = { answer: data, evidence: [] };
                    }
                    if (donePayload && typeof donePayload.answer === "string") {
                        assistantText = donePayload.answer;
                        setBubbleMarkdown(bubble, assistantText);
                        appendEvidenceToBubble(bubble, donePayload.evidence || []);
                    }
                    updateStatus("Complete");
                    progressTracker.complete("Answer ready");
                    await loadSidebar();
                    return;
                } else if (eventType === "error") {
                    const errorText = data || "Run failed";
                    setBubbleMarkdown(bubble, `Error: ${errorText}`);
                    updateStatus("Failed");
                    progressTracker.fail(`Error: ${errorText}`);
                    await loadSidebar();
                    return;
                }
            }
        }
    }

    chatForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const question = chatInput.value.trim();
        if (!question) return;

        appendMessage("user", question);
        chatInput.value = "";
        sendButton.disabled = true;

        try {
            const response = await fetch(`/api/chats/${encodeURIComponent(currentChatId)}/messages`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ question })
            });
            if (!response.ok) {
                const text = await response.text();
                throw new Error(text || `HTTP ${response.status}`);
            }
            const payload = await response.json();
            activeRunId = payload.run_id;
            const sidebarRefresh = loadSidebar();
            await startRunStream(payload.run_id);
            await sidebarRefresh;
        } catch (error) {
            const bubble = appendMessage("assistant", "");
            setBubbleMarkdown(bubble, `Error: ${error.message}`);
            updateStatus("Failed");
        } finally {
            sendButton.disabled = false;
            chatInput.focus();
        }
    });

    newChatButton.addEventListener("click", async () => {
        const response = await fetch("/api/chats", { method: "POST" });
        if (!response.ok) return;
        const payload = await response.json();
        window.location.href = `/investigate/${payload.chat_id}`;
    });

    function setSidebarExpanded(expanded) {
        if (!chatSidebar || !chatHistoryToggle) return;
        chatSidebar.classList.toggle("expanded", expanded);
        chatHistoryToggle.setAttribute("aria-expanded", expanded ? "true" : "false");
        chatHistoryToggle.textContent = expanded ? "Hide chats" : "Chats";
    }

    function setupSidebarForViewport() {
        if (window.matchMedia("(max-width: 960px)").matches) {
            setSidebarExpanded(false);
        } else {
            setSidebarExpanded(true);
        }
    }

    if (chatHistoryToggle) {
        chatHistoryToggle.addEventListener("click", () => {
            const expanded = chatSidebar && chatSidebar.classList.contains("expanded");
            setSidebarExpanded(!expanded);
        });
    }

    (async () => {
        setupSidebarForViewport();
        window.addEventListener("resize", setupSidebarForViewport);
        await loadSidebar();
        await loadThread();
        chatInput.focus();
    })();
})();
</script>
{% endblock %}
